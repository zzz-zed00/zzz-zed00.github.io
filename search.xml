<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络安全架构</title>
      <link href="/2019/08/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/"/>
      <url>/2019/08/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="网络安全架构"><a href="#网络安全架构" class="headerlink" title="网络安全架构"></a>网络安全架构</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows Services 2008 和Windows Xp的安装</title>
      <link href="/2019/08/27/Windows-services-2008-%E5%92%8Cwindows-xp%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/27/Windows-services-2008-%E5%92%8Cwindows-xp%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-services-2008-和windows-xp的安装"><a href="#Windows-services-2008-和windows-xp的安装" class="headerlink" title="Windows services 2008 和windows xp的安装"></a>Windows services 2008 和windows xp的安装</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Windows操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qos(服务质量)</title>
      <link href="/2019/08/27/Qos(%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F)/"/>
      <url>/2019/08/27/Qos(%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F)/</url>
      
        <content type="html"><![CDATA[<h1 id="Qos-服务质量"><a href="#Qos-服务质量" class="headerlink" title="Qos(服务质量)"></a>Qos(服务质量)</h1><p>队列形式：</p><p>使某个服务的流量优先，</p>]]></content>
      
      
      
        <tags>
            
            <tag> 路由交换技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NAT网络地址转换以及PPP Pap和chap</title>
      <link href="/2019/08/21/NAT%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/08/21/NAT%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="NAT网络地址转换以及PPP-pap和chap"><a href="#NAT网络地址转换以及PPP-pap和chap" class="headerlink" title="NAT网络地址转换以及PPP pap和chap"></a>NAT网络地址转换以及PPP pap和chap</h1><h2 id="NAT网络地址转换"><a href="#NAT网络地址转换" class="headerlink" title="NAT网络地址转换"></a>NAT网络地址转换</h2><p>使用少量的共有网络代表多个私有地址的方式，有助于缓解可用的空间的枯竭</p><p>IPv4  可用地址2^32-2=40亿</p><p>NET：解决网络地址不足的问题</p><p>NET：将内网隐藏起来</p><p>IPv6: 2^128=</p><p>静态转换：一对一，应用于内部网络服务器等这些对外发布的凭他</p><p>动态转换：更多对多，应用于将公网申请的多个地址做成地址池，内部网络转换到这个地址池上网</p><p>过载PAT：多对一</p><h3 id="静态NAT转化"><a href="#静态NAT转化" class="headerlink" title="静态NAT转化"></a>静态NAT转化</h3><p>设置静态转化</p><p>Router(config)#ip nat inside source static 源地址  目标转化的公网地址</p><p>将接口标记为入口网络</p><p>Router(config-if)#ip nat inside </p><p>将接口标记为外部网络</p><p>Router(config-if)#ip nat outside </p><h3 id="动态NAT转换公网"><a href="#动态NAT转换公网" class="headerlink" title="动态NAT转换公网"></a>动态NAT转换公网</h3><p>动态NAT转化公网需要一个公网地址池，由内网发出去的请求会经过NAT转换成地址池中的公网IP</p><p>设置地址池</p><p>Router(config)#ip nat pool 地址池名字  地址池的起始地址  结束地址 netmask  掩码</p><p>添加一个ACL</p><p>Router(config)#access-list 10 permit 内网地址段  反掩码</p><p>建立动态转换</p><p>Router(config)#ip nat inside source list 10 pool 地址池名字  overload(超负载)</p><p>动态地址还是要在端口标记入口网络和外部网络</p><h2 id="PPP-pap和chap"><a href="#PPP-pap和chap" class="headerlink" title="PPP pap和chap"></a>PPP pap和chap</h2><h3 id="PPP-pap认证"><a href="#PPP-pap认证" class="headerlink" title="PPP pap认证"></a>PPP pap认证</h3><p>在第一个端口上配置PPP pap验证，并设置一个用户名和密码</p><p>Router(config)#username admin password ccie</p><p> Router(config)#int s0/3/0</p><p>Router(config-if)#encapsulation ppp </p><p>Router(config-if)#ppp authentication pap</p><p> 在第二个路由器的端口上同样开启PPP验证，并用PPP pap 发送验证</p><p>Router(config)#int s0/3/0</p><p>Router(config-if)#en ppp </p><p>Router(config-if)#ppp pap sent-username admin password ccie</p><h3 id="PPP-pap-chap验证"><a href="#PPP-pap-chap验证" class="headerlink" title="PPP pap chap验证"></a>PPP pap chap验证</h3><p>在两边同时开启验证，并配置挑战应答的名字和密码</p><p>密码一样，名字为对方的名字</p><p>Router(config-if)#en ppp </p><p>Router(config-if)#PPP au chap</p>]]></content>
      
      
      
        <tags>
            
            <tag> 路由交换技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由重分布与路径控制</title>
      <link href="/2019/08/21/%E8%B7%AF%E7%94%B1%E9%87%8D%E5%88%86%E5%B8%83%E4%B8%8E%E8%B7%AF%E5%BE%84%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/08/21/%E8%B7%AF%E7%94%B1%E9%87%8D%E5%88%86%E5%B8%83%E4%B8%8E%E8%B7%AF%E5%BE%84%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="路由重分布与路径控制"><a href="#路由重分布与路径控制" class="headerlink" title="路由重分布与路径控制"></a>路由重分布与路径控制</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 路由交换技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSPF路由协议</title>
      <link href="/2019/08/20/OSPF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/08/20/OSPF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="OSPF路由协议"><a href="#OSPF路由协议" class="headerlink" title="OSPF路由协议"></a>OSPF路由协议</h1><p>封装IP头部协议: 88eigrp   89ospf</p><p>工业标准，工作在IP 网络</p><p>组播地址：224.0.0.5 224.0.0.6 </p><p>链路状态型的路由器</p><h2 id="OSPF概述"><a href="#OSPF概述" class="headerlink" title="OSPF概述"></a>OSPF概述</h2><p>交换hello数据包创建邻居关系</p><h2 id="链路状态路由协议"><a href="#链路状态路由协议" class="headerlink" title="链路状态路由协议"></a>链路状态路由协议</h2><p>无环路由</p><h2 id="OSPF分层路由"><a href="#OSPF分层路由" class="headerlink" title="OSPF分层路由"></a>OSPF分层路由</h2><p>划分区域：</p><p>1.减少路由表的路由条目</p><p>2.拓扑发生变化时，只影响本区域的数据库</p><p>3.每隔30mins泛数据库信息，划分区域后，只在本区域泛洪</p><p>4.网络设计灵活</p>]]></content>
      
      
      
        <tags>
            
            <tag> 路由交换技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级距离矢量路由协议EIGRP</title>
      <link href="/2019/08/16/%E9%AB%98%E7%BA%A7%E8%B7%9D%E7%A6%BB%E7%9F%A2%E9%87%8F%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AEEIGRP/"/>
      <url>/2019/08/16/%E9%AB%98%E7%BA%A7%E8%B7%9D%E7%A6%BB%E7%9F%A2%E9%87%8F%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AEEIGRP/</url>
      
        <content type="html"><![CDATA[<h1 id="高级距离矢量路由协议EIGRP"><a href="#高级距离矢量路由协议EIGRP" class="headerlink" title="高级距离矢量路由协议EIGRP"></a>高级距离矢量路由协议EIGRP</h1><h2 id="EIGRP的特点"><a href="#EIGRP的特点" class="headerlink" title="EIGRP的特点"></a>EIGRP的特点</h2><p>100%无环路的无类路由</p><p>可以在两条开销不相等的路由上实现负载均衡</p><p>支持多种网络协议</p><p>在网络中任一点手动汇总</p><h2 id="EIGRP表"><a href="#EIGRP表" class="headerlink" title="EIGRP表"></a>EIGRP表</h2><p>邻居表：存有下一跳地址</p><p>拓扑表：存有所有最佳路由条目，以及其他路由路径</p><p>路由表：存有所有最佳路由条目</p><h2 id="AD和FD"><a href="#AD和FD" class="headerlink" title="AD和FD"></a>AD和FD</h2><p>通告距离(AD)：也称为报告距离，下一跳路由器到目的地的度量值</p><p>可行距离(FD)：本地路由器到达目的地的度量值</p><h2 id="后继者和可行后继"><a href="#后继者和可行后继" class="headerlink" title="后继者和可行后继"></a>后继者和可行后继</h2><h3 id="后继者"><a href="#后继者" class="headerlink" title="后继者"></a>后继者</h3><p>后继者就是相邻路由具有最低成本的路径到达目的地</p><p>后继路由用于转发数据包</p><p>如果他们具有相同FD，可以以存在多条路径</p><h3 id="可行后继"><a href="#可行后继" class="headerlink" title="可行后继"></a>可行后继</h3><p>离目的很近的邻居，但不是最低开销。</p><p>一个可行后继确保一个无环拓扑，他的AD必须小于后继的FD</p><p>可行后继和后继在同一时间进行选择，但只保存在拓扑表作为备份路径</p><p>拓扑表可以保存多个可行后继为一个目的地</p><h2 id="EIGRP度量值计算"><a href="#EIGRP度量值计算" class="headerlink" title="EIGRP度量值计算"></a>EIGRP度量值计算</h2><p>带宽 ————使用的最小的带宽</p><p>可靠性————衡量一个连接失败的可能性</p><p>延迟————恒力量一个包需要穿越路由的时间</p><p>负载————反映了多少流量使用链接</p><p>MTU：————默认情况下使用，只有带宽和延迟</p><p>metric值的计算方法：<strong>metric**</strong>值=256（10^7/bw+dly之和/10）</p><p>​                                            bw：最小带宽        dly：延迟之和路由传递方向所有入接口的dly值的垒加</p><h2 id="EIGRP的配置"><a href="#EIGRP的配置" class="headerlink" title="EIGRP的配置"></a>EIGRP的配置</h2><p>Router(config)#router eigrp 10            (EIGRP的名字)</p><p>Router(config-router)#network 11.1.1.0 0.0.0.255    (掩码可选可不选)</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>等价负载均衡</p><p>非等价负载均衡：</p><p>​                    条目数量配置：maximum-paths</p><p>​                    非等价负载均衡配置：Router(config-router)#variance v</p><p>​                        v的算法： (v  *  S FD) /FS FD</p><h2 id="EIGRP-MD5身份验证"><a href="#EIGRP-MD5身份验证" class="headerlink" title="EIGRP  MD5身份验证"></a>EIGRP  MD5身份验证</h2><p>路由器对每个他发的包进行标识</p><p>路由器验证接收到的每隔路由更新数据包的来源</p><p>每个参与的邻居都必须配置相同的密钥</p><p>配置步骤：</p><p>1.创建密钥链</p><p>Router(config)#key chain 10  (10是密钥链的名字)</p><p>2.对每个密钥分配密钥ID</p><p>Router(config-keychain)#key 1   (1是密钥的ID，密钥可以配置多个)</p><p>3.标识密钥字符串</p><p>Router(config-keychain-key)#key-string 123456</p><p>4.在端口上启用MD5身份验证</p><p>Router(config-if)#ip authentication mode eigrp 10 md5 (10是密钥链的名字)</p><p>5.在端口使用密钥链</p><p>Router(config-if)#ip authentication key-chain eigrp 10 10      (第一个10是EIGRP的名字，第二个是钥匙链的名字)</p><h2 id="配置被动接口"><a href="#配置被动接口" class="headerlink" title="配置被动接口"></a>配置被动接口</h2><p>被动接口不接受不发送路由表信息</p><p>Router(config-router)# passive-interface Loopback0</p>]]></content>
      
      
      
        <tags>
            
            <tag> 路由交换技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协议</title>
      <link href="/2019/08/15/%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/08/15/%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h2 id="Telnet协议"><a href="#Telnet协议" class="headerlink" title="Telnet协议"></a>Telnet协议</h2><p>Telnet允许客户端通过一个协商来与远程设备进行通信</p>]]></content>
      
      
      
        <tags>
            
            <tag> 路由交换技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态路由</title>
      <link href="/2019/08/15/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"/>
      <url>/2019/08/15/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="动态路由RIP"><a href="#动态路由RIP" class="headerlink" title="动态路由RIP"></a>动态路由RIP</h1><p>根据拓扑或流量改变而自动调整</p><h2 id="RIP解决环路的方法"><a href="#RIP解决环路的方法" class="headerlink" title="RIP解决环路的方法"></a>RIP解决环路的方法</h2><p>1.定义最大跳数（15）</p><p>2.水平分割</p><p>3.路由毒化或毒性逆转</p><p>4.抑制计时器</p><p>5.触发更新</p><h2 id="RIP路由协议版本"><a href="#RIP路由协议版本" class="headerlink" title="RIP路由协议版本"></a>RIP路由协议版本</h2><p>RIPv1 发送路由更新时不携带子网掩码，宣告主类网络，属于有类路由协议</p><p>发送路由更新，目标是广播地址：255.255.255.255</p><p>RIPv2发送路由更新时携带子网掩码，属于无类网络</p><h2 id="开启RIP协议"><a href="#开启RIP协议" class="headerlink" title="开启RIP协议"></a>开启RIP协议</h2><p>R1(config)#router rip        开启RIP协议 </p><p>R1(config-router)#version 2     选择版本</p><p>R1(config-router)#network 10.1.0.1     宣告</p>]]></content>
      
      
      
        <tags>
            
            <tag> 路由交换技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP和DoD模型</title>
      <link href="/2019/08/15/TCPIP%E5%92%8CDoD%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/08/15/TCPIP%E5%92%8CDoD%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-IP和DoD模型"><a href="#TCP-IP和DoD模型" class="headerlink" title="TCP/IP和DoD模型"></a>TCP/IP和DoD模型</h1><h2 id="DoD-模型"><a href="#DoD-模型" class="headerlink" title="DoD 模型"></a>DoD 模型</h2><p>应用层：进程/应用层：对应应用层、表示层、会话层</p><p>传输层：主机到主机层： 对应传输层</p><p>网际互连网：因特网层： 网络层</p><p>网络接口层：网络接入层：  数据链路层和物理层</p><h2 id="进程-应用层协议"><a href="#进程-应用层协议" class="headerlink" title="进程/应用层协议"></a>进程/应用层协议</h2><p>Telnet：远程连接协议，提供远程登陆服务，使用23端口</p><p>FTP：文件传输协议，FTP客户端和服务器之间的连接时可靠的，为数据传输提供可可靠性的保证  使用20、21端口，20端口用于传输数据，21都那口用于传输控制信息</p><p>TFTP：简单文本传输协议，以UDP为基础的应用层协议，使用69端口</p><p>NFS：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 路由交换技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSI 参考模型</title>
      <link href="/2019/08/15/OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/08/15/OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h1><p>是IOS开发的</p><h2 id="OSI-模型包含7层"><a href="#OSI-模型包含7层" class="headerlink" title="OSI 模型包含7层"></a>OSI 模型包含7层</h2><p>OSI模型包含7层，分为两组：</p><h3 id="上三层"><a href="#上三层" class="headerlink" title="上三层"></a>上三层</h3><p>应用层：用户界面  ————文件，打印，消息，数据库和应用程序服务</p><p>​                用户和计算机交流的场所，是实际应用程序之间的接口，如FTP、TFTP等</p><p>表示层： 表示数据，进行加密等处理  ————数据加密，压缩和转换服务</p><p>​                向应用层提供数据，负责数据转换和代码格式化。</p><p>会话层： 将不同应用程序的数据分类  ————对话控制</p><p>​                负责在表示层实体之间建立、管理、和终止会话，还对设备或节点之间对话进行控制。</p><h3 id="下四层"><a href="#下四层" class="headerlink" title="下四层"></a>下四层</h3><p>传输层： 提供可靠或不可靠的传输，重传前执行纠错  ————端到端连接</p><p>​                将数据进行分段并重组为数据流。并在发送主机和目标主机之间建立一个逻辑链接。TCP三次握手连接，  UDP</p><h4 id="TCP-UDP协议"><a href="#TCP-UDP协议" class="headerlink" title="TCP/UDP协议"></a>TCP/UDP协议</h4><p>​                TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p><p>​                1.客户端发送一个syn包到服务器，并且自身进入SYN_SEND状态</p><p>​                2.服务器接收到syn包，确认客户的syn(ack=j+1)，同时自己也发送一个SYN包，并切自身进入SYN_RECV状态</p><p>​                3.客户端收到syn包，确认服务器的SYN(ack=k+1)，客户端和服务器进入ESTABLISHED状态，完成三次握手</p><p>网络层： 提供逻辑地址，路由器使用他们选择路径  ————路由选择</p><p>​                管理设备编址、跟踪设备在网络中的位置并确定最佳的数据传输路径，网络层必须在位于不同网络中的设备之间传输数据流。路由器，I P</p><p>数据链路层： 将分组拆分为字节，并将字节合成帧  ————成帧</p><p>​                介质访问控制（MAC）子层802.3 </p><p>​                逻辑链路控制（LLC）子层802.2</p><p>​                交换机  LL C    MAC</p><p>物理层： 设备间传输比特        ————物理拓扑</p><p>​                线缆，双绞线，直连线，光缆，集线器</p><h2 id="数据封装与解封装"><a href="#数据封装与解封装" class="headerlink" title="数据封装与解封装"></a>数据封装与解封装</h2><p><img src="http://wx4.sinaimg.cn/large/006BhCi3gy1g60eartagtj30c806xdhw.jpg" alt></p><h2 id="网络架构三层模型"><a href="#网络架构三层模型" class="headerlink" title="网络架构三层模型"></a>网络架构三层模型</h2><p>核心层</p><p>​                三层交换机：考虑性能，冗余，传输速率</p><p>汇聚层，集聚层</p><p>​                网络互联</p><p>接入层</p><p>​                交换机</p>]]></content>
      
      
      
        <tags>
            
            <tag> 路由交换技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nmap的使用</title>
      <link href="/2019/08/09/nmap/"/>
      <url>/2019/08/09/nmap/</url>
      
        <content type="html"><![CDATA[<h1 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h1><h2 id="nmap的功能"><a href="#nmap的功能" class="headerlink" title="nmap的功能"></a>nmap的功能</h2><p>·扫描主机端口</p><p>·探测主机是否在线</p><p>·推断主机操作系统类型</p><h3 id="sT-tcp扫描"><a href="#sT-tcp扫描" class="headerlink" title="-sT  tcp扫描"></a>-sT  tcp扫描</h3><p>全连接扫描 ：  发送一个tcp的连接，不需要root用户即可，容易被探测到</p><h3 id="sS-SYN扫描"><a href="#sS-SYN扫描" class="headerlink" title="-sS    SYN扫描"></a>-sS    SYN扫描</h3><p>半连接扫描：不是一个完整的tcp连接，只发送一个SYN包，返回        SYN|ACK包说明端口正在监听，如果返回RST包说明端口没有监听程序，痕迹少，不易被发现，不过要root权限</p><h3 id="sF-FIN扫描"><a href="#sF-FIN扫描" class="headerlink" title="-sF     FIN扫描"></a>-sF     FIN扫描</h3><p>​    秘密扫描   除SYN、ACK其他位置</p><h3 id="sX-Xmas扫描"><a href="#sX-Xmas扫描" class="headerlink" title="-sX    Xmas扫描"></a>-sX    Xmas扫描</h3><p>   秘密扫描    FIN、URG、PUSH位置</p><h3 id="sN-null扫描"><a href="#sN-null扫描" class="headerlink" title="-sN   -null扫描"></a>-sN   -null扫描</h3><p>   密码扫描   标志位全为0，发送TCP分组</p><h3 id="sP-ping扫描"><a href="#sP-ping扫描" class="headerlink" title="-sP   ping扫描"></a>-sP   ping扫描</h3><p>​    同时使用ICMP  TCP  ACK 80返回RST说明主机运行</p><h3 id="sU-UDP扫描"><a href="#sU-UDP扫描" class="headerlink" title="-sU  UDP扫描"></a>-sU  UDP扫描</h3><p>   发送0字节UDP包，快速扫描windows的UDP端口</p><h3 id="sA-ACK扫描"><a href="#sA-ACK扫描" class="headerlink" title="-sA  ACK扫描"></a>-sA  ACK扫描</h3><p>  TCP ACK扫描</p><p>，防火墙开启时，查看防火墙未过滤端口</p><h3 id="P0"><a href="#P0" class="headerlink" title="-P0"></a>-P0</h3><p>  NMAP扫描前不ping主机</p><h3 id="PT"><a href="#PT" class="headerlink" title="-PT"></a>-PT</h3><p>  扫描前使用TCP  ACK包确定主机是否在运行  默认80端口<br>    -PS  TCP  SYN扫描</p><h3 id="PI"><a href="#PI" class="headerlink" title="-PI"></a>-PI</h3><p>  ping扫描</p><h3 id="O"><a href="#O" class="headerlink" title="-O"></a>-O</h3><p> 扫描TCP/IP指纹特征，确定目标主机类型</p><h3 id="v"><a href="#v" class="headerlink" title="-v"></a>-v</h3><p> 冗余模式扫描，可以得到扫描时的详细信息</p><h3 id="S"><a href="#S" class="headerlink" title="-S"></a>-S</h3><p>   欺骗扫描时，用来指定主机IP</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Html标签</title>
      <link href="/2019/08/09/html%E6%A0%87%E7%AD%BE/"/>
      <url>/2019/08/09/html%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="html标签"><a href="#html标签" class="headerlink" title="html标签"></a>html标签</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'http://baidu.com'</span>&gt;</span>baidu<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line">定义锚  点击baidu按钮会返回定义的地址</span><br><span class="line"><span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">"People  Paksda JSAlksa"</span>&gt;</span>PPJ<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span></span><br><span class="line">定义一个缩写  在鼠标移动到定义的缩写上时会显示该缩写定义的信息</span><br><span class="line"><span class="tag">&lt;<span class="name">acronym</span> <span class="attr">title</span>=<span class="string">"Jjas Kajsd Sasjdka"</span>&gt;</span>JKS<span class="tag">&lt;/<span class="name">acronym</span>&gt;</span></span><br><span class="line">定义一个首字母的缩写，基本同上</span><br><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span>标记作者信息<span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">area</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span>定义文章、评论、博客、帖子等<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">str</span>=<span class="string">"/xx/xx.ogg"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span>anjd<span class="tag">&lt;/<span class="name">audio</span>&gt;</span> </span><br><span class="line">str为地址  controls播放按钮</span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>定义粗体字<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base定义页面中的所有默认地址或目标</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bdo</span> <span class="attr">dir</span>=<span class="string">"rtl"</span>&gt;</span>定义文本方向<span class="tag">&lt;/<span class="name">bdo</span>&gt;</span> </span><br><span class="line">    输出为从右往左</span><br><span class="line"><span class="tag">&lt;<span class="name">big</span>&gt;</span>放大标签<span class="tag">&lt;/<span class="name">big</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span>换行</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>dd<span class="tag">&lt;/<span class="name">button</span>&gt;</span>按钮</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"asa"</span>&gt;</span>按钮</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2019/08/09/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2019/08/09/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="本地验证绕过-js验证绕过"><a href="#本地验证绕过-js验证绕过" class="headerlink" title="本地验证绕过  js验证绕过"></a>本地验证绕过  js验证绕过</h2><p>​    文件上传时在本地服务器进行验证，此时可以将php文件的后缀改为符合要求的，然后用burp suite抓包，再将后缀改为php即可</p><h2 id="文件后缀绕过"><a href="#文件后缀绕过" class="headerlink" title="文件后缀绕过"></a>文件后缀绕过</h2><p>​    建立一个a.php.xxx的文件，xxx为读不出来的文件后缀即可<br>​    原理是文件读取时是从右往左读取，当后缀读不出来时，到.php时会执行php文件</p><h2 id="文件类型绕过"><a href="#文件类型绕过" class="headerlink" title="文件类型绕过"></a>文件类型绕过</h2><p>​    验证文件类型的mime值，当mime值符合要求时才能上传，此时只需要burp suite抓包，将mime值改为符合要求的即可</p><h2 id="文件截断绕过"><a href="#文件截断绕过" class="headerlink" title="文件截断绕过"></a>文件截断绕过</h2><p>源码对上传文件进行php限制<br>截断字符:0x00    %00    /00   char()为null，后面内容会被截断<br>利用条件：php版本小于5.3.4    php参数magic_quotes_gpc设置为关off</p><h2 id="竞争上传（多线程，并发）："><a href="#竞争上传（多线程，并发）：" class="headerlink" title="竞争上传（多线程，并发）："></a>竞争上传（多线程，并发）：</h2><p>源码对上传的文件类型为php的存储后删除。<br>通过上传php生成一句话，在路径下生成反弹木马<br>自动生成一句话木马的脚本。</p><h2 id="图片马"><a href="#图片马" class="headerlink" title="图片马"></a>图片马</h2><p>cat 1.jpg/a  2.php/b  3.jpg<br>copy  1.jpg/a  2.php/b  3.jpg   将图片和php制作成一个图片马<br>此上传只有对方有文件包含漏洞时才能使用</p><h2 id="二次渲染"><a href="#二次渲染" class="headerlink" title="二次渲染"></a>二次渲染</h2><p>待定······</p>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热备份路由协议</title>
      <link href="/2019/08/09/%E7%83%AD%E5%A4%87%E4%BB%BD%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/08/09/%E7%83%AD%E5%A4%87%E4%BB%BD%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="热备份路由协议"><a href="#热备份路由协议" class="headerlink" title="热备份路由协议"></a>热备份路由协议</h1><h2 id="HSRP配置"><a href="#HSRP配置" class="headerlink" title="HSRP配置"></a>HSRP配置</h2><p>sw(config)#int vlan 10 </p><p>sw(config-if)#standby 10 ip 192.168.10.250          将vlan10这个端口设置到10并配置一个地址</p><p>sw(config-if)#standby 10 priority 120   设置优先级</p><p>sw(config)#standby  10  times 3  10  设置每隔3s发一次，10s保持</p><p>sw(config)#standby 10 preempt  设置抢占模式</p><p>sw(config)#standby 10 track f0/22   设置跟踪端口</p><p>两边路由器都要设置</p>]]></content>
      
      
      
        <tags>
            
            <tag> 路由交换技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置静态路由</title>
      <link href="/2019/08/09/%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/"/>
      <url>/2019/08/09/%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h1><p>IP route +目标地址  +转发接口地址</p><h2 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h2><p>在不知道外部网络的情况下</p><p>IP route 0.0.0.0 0.0.0.0 f0/0</p><h2 id="使用静态路由实现负载均衡"><a href="#使用静态路由实现负载均衡" class="headerlink" title="使用静态路由实现负载均衡"></a>使用静态路由实现负载均衡</h2><p>R1(config)#ip route 23.1.1.0 255.255.255.0 172.16.1.2</p><p>R1(config)#ip route 23.1.1.0 255.255.255.0 12.1.1.2</p><p>R2(config)#ip route 12.1.1.0 255.255.255.0 172.16.1.1</p><p>R2(config)#ip route 12.1.1.0 255.255.255.0 23.1.1.1</p><p>R3(config)#ip route 172.16.1.0 255.255.255.0 12.1.1.1</p><p>R3(config)#ip route 172.16.1.0 255.255.255.0 23.1.1.2</p><h2 id="选择静态路由"><a href="#选择静态路由" class="headerlink" title="选择静态路由"></a>选择静态路由</h2><p>静态路由会根据子网掩码大的优先选择，即静态路由的最长匹配原则</p><h2 id="浮动静态路由"><a href="#浮动静态路由" class="headerlink" title="浮动静态路由"></a>浮动静态路由</h2><p>R3(config)#ip route 172.16.1.0 255.255.255.0 23.1.1.2 10(浮动，值越小优先)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 路由交换技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ssh远程管理网路设备</title>
      <link href="/2019/08/09/ssh%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E7%BD%91%E8%B7%AF%E8%AE%BE%E5%A4%87%EF%BC%9A/"/>
      <url>/2019/08/09/ssh%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E7%BD%91%E8%B7%AF%E8%AE%BE%E5%A4%87%EF%BC%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="ssh远程管理网路设备："><a href="#ssh远程管理网路设备：" class="headerlink" title="ssh远程管理网路设备："></a>ssh远程管理网路设备：</h1><p>telnet  也可以管理，不过telnet使明文传输  telnet使用23端口</p><p>为了提高安全，使用ssh，密码进行了加密  使用22端口</p><p>配置ssh：</p><p>配置交换机名字</p><p>switch(config)#hostname  sw1</p><p>配置域名</p><p>sw1(config)#ip domain-name ccie.com</p><p>配置加密方式</p><p>sw1(config)#crypto key generate rsa</p><p>配置密码加密长度</p><p>512的倍数</p><p>设置用户名和密码</p><p>sw1(config)#username admin password ccie</p><p>或者sw1(config)#username admin  privilege（权限级别）  0  secret ccie</p><p>server(config)#line vty 0 4</p><p>server(config-line)#exec-timeout 10 0（10分钟没有进行操作，断开连接）</p><p>server(config-line)#logging synchronous</p><p>server(config-line)#login local</p><p>server(config-line)#transport input ssh（选择登陆方式）</p><p>ssh -l +用户名 +ip</p>]]></content>
      
      
      
        <tags>
            
            <tag> 路由交换技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入绕过</title>
      <link href="/2019/08/09/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87/"/>
      <url>/2019/08/09/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入绕过"><a href="#SQL注入绕过" class="headerlink" title="SQL注入绕过"></a>SQL注入绕过</h1><h2 id="1-空格绕过："><a href="#1-空格绕过：" class="headerlink" title="1.空格绕过："></a>1.空格绕过：</h2><p>​    /**/    %a0   括号也可以绕过空格 括号两边可以不用加空格如：where（1=1）</p><h2 id="2-引号绕过："><a href="#2-引号绕过：" class="headerlink" title="2.引号绕过："></a>2.引号绕过：</h2><p>​    十六进制绕过：将引号括起来的语句用十六进制表示</p><h2 id="3-逗号绕过："><a href="#3-逗号绕过：" class="headerlink" title="3.逗号绕过："></a>3.逗号绕过：</h2><p>​    from  for绕过，如select substr(database() from 1 for 1)<br>​    join绕过union select 1,2   #等价于<br>​        union select * from (select 1)a join (select 2)b<br>​    like绕过    limit可以使用offset绕过<br>​        如select *from news limit 0,1   #等价于<br>​            select * from news limit 1 offset 0</p><h2 id="4-大于号-gt-小于号-lt-绕过"><a href="#4-大于号-gt-小于号-lt-绕过" class="headerlink" title="4.大于号&gt;小于号&lt;绕过"></a>4.大于号&gt;小于号&lt;绕过</h2><p>​    greatest()、least()前者返回最大值，后者返回最小值<br>​    greatest(1,5,6,2,3,1)  返回6<br>​    between and  #between a and b  返回a和b之间的数据  不包含b</p><h2 id="5-or-and-xor-not-绕过"><a href="#5-or-and-xor-not-绕过" class="headerlink" title="5.or   and   xor  not  绕过"></a>5.or   and   xor  not  绕过</h2><p>​    and 用&amp;&amp;   or用||   xor用|  not用!</p><h2 id="6-绕过注释符号-过滤注释符号"><a href="#6-绕过注释符号-过滤注释符号" class="headerlink" title="6.绕过注释符号   过滤注释符号"></a>6.绕过注释符号   过滤注释符号</h2><p>​    使语句闭合</p><h2 id="7-绕过"><a href="#7-绕过" class="headerlink" title="7.=绕过"></a>7.=绕过</h2><p>​    like    rlike  regexp  或者用“或者”</p><h2 id="8-绕过union-select-where等sql常用语句"><a href="#8-绕过union-select-where等sql常用语句" class="headerlink" title="8.绕过union  select  where等sql常用语句"></a>8.绕过union  select  where等sql常用语句</h2><p>​    注释符绕过。。暂定 看不懂<br>​    大小写绕过  #语句大小写混合输入  id=-1’ UnIoN SeLecT<br>​    内联注释绕过/*！  */<br>​    双关键字绕过  适用于只过滤一次关键字的注入</p><h2 id="9-通用绕过"><a href="#9-通用绕过" class="headerlink" title="9.通用绕过"></a>9.通用绕过</h2><p>​    编码绕过   urlencode   ascii  hex  unicode</p><h2 id="10-宽字节注入"><a href="#10-宽字节注入" class="headerlink" title="10.宽字节注入"></a>10.宽字节注入</h2><p>​    %df和转义符形成一个特殊字符从而吃掉‘转义符’ 让%df后面的字符逃过转义</p><h2 id="11-等价函数"><a href="#11-等价函数" class="headerlink" title="11.等价函数"></a>11.等价函数</h2><p>​    datadir()=@@datadir等</p>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/2019/08/08/SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/08/08/SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>sql注入是web应用程序对用户的输入数据的合法性没有判断，前端传入的数据是攻击者可控的，并且可以带入数据库查询，攻击者可以构造不同的sql语句来实现自己的目的</p><h2 id="注入之前的尝试"><a href="#注入之前的尝试" class="headerlink" title="注入之前的尝试"></a>注入之前的尝试</h2><p>我们可以通过输入带有特殊符号的不同的参数来对输入点进行测试，该位置是否存在注入点。</p><p>1</p><p>1 and 1=1</p><p>1 and 1=2</p><p>1 or 1=2</p><p>1’</p><p>1’ and 1=1</p><p>1’ and 1=2</p><p>1’ or 1=1</p><p>如果出现错误页面就说明存在注入点，特殊符号不仅仅是指”  ‘  “  也包括()””甚至也可能不止一层</p><h2 id="MySQL与sql注入的一些知识点"><a href="#MySQL与sql注入的一些知识点" class="headerlink" title="MySQL与sql注入的一些知识点"></a>MySQL与sql注入的一些知识点</h2><p>在MySQL5.0以上的版本，数据库中存在一个“information_schema”的数据库，我们需要记住该数据库中的三个表，schemamata,tables,columns</p><p>·schemamata这个表存放所有数据库的名字，表中数据库的名字字段是schema_name </p><p>·tables表存放所有数据库的库名以及表名，字段分别为table_schema和table_name</p><p>·columns表中存放用户创建的所有数据库的库名、表名、字段名，他们的字段名分别是，table_schema,  table_name,  column_name </p><h2 id="一些常用的函数"><a href="#一些常用的函数" class="headerlink" title="一些常用的函数"></a>一些常用的函数</h2><p>select   查询的字段名  from 库名.表名</p><p>limit的用法</p><p>limit的格式是limit(n,m)，其中n是开始的位置，m为取几条记录</p><p>如select * from test.user limit 1,2</p><p>查询所有列从test库中的user表，从第二行开始一共取2行</p><p>version()   当前数据库的版本</p><p>database()当前网站使用的数据库</p><p>user()当前MySQL的用户</p><p>三种常用的注释符</p><p>1.#</p><p>2.–+或者–空格</p><p>3./**/    *中的内容会被注释</p><h2 id="union注入"><a href="#union注入" class="headerlink" title="union注入"></a>union注入</h2><p>联合注入是在参数输入的地方拼接另一个查询语句，使数据库执行此语句，从而达到目的</p><p>union select database() –+</p><p>union select table_name from intormation_schema.tables where table_schema=database() –+</p>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记</title>
      <link href="/2019/08/08/python/"/>
      <url>/2019/08/08/python/</url>
      
        <content type="html"><![CDATA[<h1 id="python学习笔记"><a href="#python学习笔记" class="headerlink" title="python学习笔记"></a>python学习笔记</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">' '</span>，“ ”)  <span class="comment">#输出单双引号皆可  引号括起来就是字符，不括就是整型</span></span><br><span class="line"><span class="keyword">print</span> （<span class="string">'''test</span></span><br><span class="line"><span class="string">test</span></span><br><span class="line"><span class="string">test'''</span>）<span class="comment">#换行输出单双引号皆可</span></span><br><span class="line">a=input（<span class="string">'  '</span>） <span class="comment">#键盘输入a只能是str</span></span><br><span class="line"><span class="comment">#可以用a=int(a) 将a转化为整型</span></span><br><span class="line"> <span class="comment">#字符串中\可以标识' 和" ,比如</span></span><br><span class="line"><span class="string">'i\'m\''</span>ok\<span class="string">''</span>!<span class="string">' 表示 i'</span>m <span class="string">''</span>ok<span class="string">''</span>!</span><br><span class="line">s=input(<span class="string">'as'</span>,end=<span class="string">''</span>)<span class="comment">#如果显示不换行在后面加end=''，默认换行</span></span><br><span class="line"><span class="comment">#%是取余除法，是永远取整数的除法</span></span><br></pre></td></tr></table></figure><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">b'ABC'</span>   <span class="comment">#将ABC从str转化成bytes</span></span><br><span class="line"><span class="string">b'ABC'</span>.decode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">'ABC'</span>  <span class="comment">#将bytes转化为str</span></span><br><span class="line">len()<span class="comment">#可以计算字符长度</span></span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#前面传入参数&apos;&#123;0&#125;，&#123;1&#125;，&#123;2&#125;&apos;.format(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;)</span><br><span class="line">#%d  double整数型  %.2f  浮点型两位小数</span><br><span class="line">#%s  str字符串    %</span><br></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class=['a','b','c']   #class是一个集合，可以增删改的list</span><br><span class="line">len(<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">3   #<span class="title">list</span>的元素个数</span></span><br><span class="line"><span class="class"><span class="title">class</span>[0]#读取第一个元素<span class="title">class</span>[-1]读取倒数第一个元素</span></span><br><span class="line"><span class="class"><span class="title">class</span>.<span class="title">append</span><span class="params">(<span class="string">'d'</span>)</span>  #添加一个元素在末尾</span></span><br><span class="line"><span class="class"><span class="title">class</span>.<span class="title">insert</span><span class="params">(<span class="number">1</span>,<span class="string">'1'</span>)</span> #添加到索引号为1的位置</span></span><br><span class="line"><span class="class"><span class="title">class</span>.<span class="title">pop</span><span class="params">(i)</span>#删除指定位置元素</span></span><br><span class="line">class(1)='2'  #直接赋值给索引号为1的元素，从而替换该元素的值</span><br><span class="line"><span class="comment">#list中的元素可以不同，整型、字符串、等等</span></span><br><span class="line">class1=[<span class="string">'l'</span>.<span class="string">'m'</span>]      </span><br><span class="line">class2=[<span class="string">'n'</span>,class1]  <span class="comment">#list中可以存放class2可以看为二维数组</span></span><br></pre></td></tr></table></figure><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t=（<span class="number">1</span>，<span class="number">2</span>）  <span class="comment">#tuple一经确定不能修改</span></span><br><span class="line">t=(<span class="number">1</span>,)  <span class="comment">#tuple在定义只有一个元素的时候用逗号消除歧义</span></span><br><span class="line">t=(<span class="string">'a'</span>,<span class="string">'b'</span>,[<span class="string">'x'</span>,<span class="string">'y'</span>]) <span class="comment">#在创建时可以在tuple中添加一个list从而改变tulp中的元素的目的</span></span><br></pre></td></tr></table></figure><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#if语句后面要加:冒号  </span></span><br><span class="line"><span class="comment">#可以执行多个elif语句</span></span><br><span class="line"><span class="comment">#if语句执行从上往下，一但符合条件立即结束</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qiujie</span><span class="params">(a,b,c)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> (b*b<span class="number">-4</span>*a*c)&lt;<span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'无实根'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x1=(-b+math.sqrt(b*b<span class="number">-4</span>*a*c))/(<span class="number">2</span>*a)</span><br><span class="line">        x2=(-b-math.sqrt(b*b<span class="number">-4</span>*a*c))/(<span class="number">2</span>*a)</span><br><span class="line">        x=move(x1,x2)</span><br><span class="line">        print(x)</span><br></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#while语句当条件满足时会一直循环，不满足时退出</span><br><span class="line">#break可以退出循环，一般与if判断语句一起用</span><br><span class="line">#continue语句会跳过当前循环，符合本语句的循环会直接跳过</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="dict–dictionary"><a href="#dict–dictionary" class="headerlink" title="dict–dictionary"></a>dict–dictionary</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=&#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>,<span class="string">'c'</span>:<span class="number">3</span>&#125; <span class="comment">#a相当于key、页码之类的  可以快速翻页查找目标</span></span><br><span class="line">d[<span class="string">'a'</span>]=<span class="number">4</span>  <span class="comment">#可以直接用key来将元素放入，后放入的元素会把前面的冲掉</span></span><br><span class="line">d.get(<span class="string">'kkk'</span>)  <span class="comment">#判断key是否在字典中也可以设定</span></span><br><span class="line">    d.get(<span class="string">'kkk'</span>,<span class="number">-1</span>)   <span class="comment">#返回-1 即当kkk不存在时返回-1</span></span><br><span class="line">d.pop(<span class="string">'kkk'</span>) <span class="comment">#删除key之后对应的元素也会被删掉</span></span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,])  <span class="comment">#set也是一组key值 但是不能存储value，没有重复的key</span></span><br><span class="line">s=set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,])  <span class="comment">#重复元素会被过滤掉</span></span><br><span class="line">s.add(<span class="number">2</span>)  <span class="comment">#add可以添加元素可以重复添加，但会被过滤</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="def"><a href="#def" class="headerlink" title="def"></a>def</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span>在随意文件里xx.py中创建一个函数为a</span><br><span class="line">·<span class="keyword">import</span> xx <span class="keyword">from</span> a  <span class="comment">#将xx中的a函数调用函数可以返回多个值，其实就是一个tuple</span></span><br></pre></td></tr></table></figure><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">*num表示把num这个list或者tuple的所有元素变成可变的参数传进去</span><br><span class="line">关键字参数<span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name,age,**k)</span>  #<span class="title">k</span>就是关键字参数 //调用该参数时可以只传入一个关键字参数</span></span><br></pre></td></tr></table></figure><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">digui</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * digui(n<span class="number">-1</span>)   <span class="comment"># 函数调用自身的一种函数，不过会出现栈溢出的问题</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">digui</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> digui2(n,<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">digui2</span><span class="params">(n,s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">return</span> digui2(n<span class="number">-1</span>,n*s)   <span class="comment">#尾递归可以解决栈溢出问题，但是大多数解释器没优化，故还是会造成栈溢出</span></span><br></pre></td></tr></table></figure><h3 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>:<span class="number">3</span>]  <span class="comment">#切取前3个元素，--不是从1开始，是从第一个元素开始</span></span><br><span class="line">[<span class="number">0</span>:<span class="number">5</span>:<span class="number">2</span>] <span class="comment">#在前5个元素中，每隔两个取一次</span></span><br><span class="line">[:<span class="number">5</span>] <span class="comment">#当第一个索引是从0开始时，0可以省略</span></span><br><span class="line">[:]  <span class="comment">#原样复制一个list</span></span><br><span class="line"><span class="string">'asdasdada'</span>  [<span class="number">0</span>:<span class="number">3</span>] <span class="comment">#字符串也可以切取，结果也是字符串</span></span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) [<span class="number">0</span>:<span class="number">2</span>]  <span class="comment">#tuple也可以切取，结果为tuple</span></span><br></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> xx <span class="keyword">in</span> l  <span class="comment">#for可以迭代各种对象</span></span><br><span class="line"><span class="keyword">from</span> colletions <span class="keyword">import</span> Iterable  <span class="comment">#collections中的iterable模块可以判断是否可以迭代</span></span><br><span class="line">isinstance([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure><h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list(range(<span class="number">1</span>,<span class="number">10</span>))  <span class="comment">#生成1到9的列表</span></span><br><span class="line">[x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>)]  <span class="comment">#生成1*1到9*9的一个列表</span></span><br><span class="line">[m+n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'abc'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'xyz'</span>]  <span class="comment">#双层循环</span></span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>生成器输出用yield ()  yield输出后停止，下次开始时从停止的地方继续</p><p>参照杨辉三角</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yang</span><span class="params">()</span>:</span></span><br><span class="line">    b=[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:    <span class="comment">#永真</span></span><br><span class="line">        <span class="keyword">yield</span> b     <span class="comment">#执行时停止循环，下次执行从下一行开始</span></span><br><span class="line">        b=[<span class="number">1</span>]+[b[i]+b[i+<span class="number">1</span>]<span class="keyword">for</span> i <span class="keyword">in</span> range(len(b)<span class="number">-1</span>)]+[<span class="number">1</span>] <span class="comment">#三个列表拼起来</span></span><br><span class="line">n=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> yang():</span><br><span class="line">    <span class="keyword">print</span> (t)</span><br><span class="line">    n=n+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n ==<span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>函数值可以赋给变量，函数本身也可以–变量可以指向函数<br>    <strong>函数可以作为一个参数使用</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'a'</span>)</span></span></span><br><span class="line"><span class="function">      <span class="title">def</span> <span class="title">gg</span><span class="params">(x,y)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(x,y)</span></span></span><br><span class="line"><span class="function">可以使用<span class="title">gg</span><span class="params">(x,fun<span class="params">()</span>)</span>来调用  不过先返回的函数？</span></span><br></pre></td></tr></table></figure><h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map()/reduce()"></a>map()/reduce()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">map(fun,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>)    <span class="comment"># map会将后面参数全部带入函数fun中</span></span><br><span class="line">reduce(gg,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,)   <span class="comment">#函数gg必须为输入两个参数的，map会将3和2参数放入，并将结果和5一起传入参数，以此类推</span></span><br></pre></td></tr></table></figure><h2 id="全局变量global"><a href="#全局变量global" class="headerlink" title="全局变量global"></a>全局变量global</h2><p>global  告诉解释器定义的为全局变量，声明一个变量变为全局变量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanshu</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a   <span class="comment">#定义全局变量</span></span><br><span class="line">    a=<span class="number">2</span></span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanshu2</span><span class="params">()</span>:</span></span><br><span class="line">    a=<span class="number">8</span></span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanshu3</span><span class="params">()</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line">hanshu2()</span><br><span class="line">hanshu3()</span><br><span class="line">hanshu()</span><br></pre></td></tr></table></figure><h2 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h2><p>\t可以让输出垂直对齐，\n换行</p><h2 id="常用函数-·补充"><a href="#常用函数-·补充" class="headerlink" title="常用函数(·补充)"></a>常用函数(·补充)</h2><p>dir()可以查看对象的使用方法</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先有类，后有对象</span><br><span class="line">对象调用类中的方法</span><br><span class="line">可以利用   .属性名=&quot;属性&quot;   给对象增加属性</span><br><span class="line">初始化方法  __init__</span><br><span class="line">在初始化方法中设定属性用  self.属性名=&quot;属性&quot;</span><br><span class="line">在对象调用类的时候会自动使用设定的初始化方法</span><br><span class="line">对__init__设置形参可以使初始化方法更加灵活</span><br><span class="line">class cat():</span><br><span class="line">def __init__(self,new_name)</span><br><span class="line">self.name=new_name</span><br><span class="line">等调用时直接传入形参</span><br><span class="line">tom=cat(&quot;tom&quot;)即可将tom赋值给self.name进而传给tom这个对象</span><br><span class="line"></span><br><span class="line">__del__会在对象销毁之前调用</span><br><span class="line">__str__能够让print输出对象的时候返回一个字符串而不是地址</span><br><span class="line"></span><br><span class="line">同一个类创造出来的对象互不干扰</span><br></pre></td></tr></table></figure><p>参照</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stu</span><span class="params">()</span>:</span>        <span class="comment">#  创建类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stu1</span><span class="params">(self)</span>:</span>     <span class="comment">#创建类的方法</span></span><br><span class="line">        print(<span class="string">"%s"</span> %self.name,end=<span class="string">""</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">syu2</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%d"</span> %self.id)</span><br><span class="line">dt=stu()</span><br><span class="line"></span><br><span class="line">dt.name=<span class="string">"dt"</span></span><br><span class="line">dt.stu1()   <span class="comment">#调用类</span></span><br><span class="line">dt.id=<span class="number">1</span></span><br><span class="line">dt.syu2()    <span class="comment">#调用类</span></span><br><span class="line">zw=stu()</span><br><span class="line">zw.name=<span class="string">"zw"</span></span><br><span class="line">zw.id=<span class="number">2</span></span><br><span class="line">zw.stu1()</span><br><span class="line">zw.syu2()</span><br></pre></td></tr></table></figure><h3 id="伪私有属性和方法"><a href="#伪私有属性和方法" class="headerlink" title="伪私有属性和方法"></a>伪私有属性和方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">定义一个类  <span class="class"><span class="keyword">class</span> <span class="title">women</span>:</span></span><br><span class="line">在设定一个属性时在属性名前加两个_可以将属性私有，私有属性只能在方法中调用，在类外不能调用</span><br><span class="line">self.__age</span><br><span class="line">同样私有方法也不能在外界访问</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__sy</span><span class="params">(self)</span>:</span></span><br><span class="line">     私有属性和私有方法同样可以调用</span><br><span class="line">xiaofang=women(<span class="string">"小芳"</span>)</span><br><span class="line">print(xiaofang._women__age)调用属性</span><br><span class="line">xiaofang._women__sy()调用方法</span><br></pre></td></tr></table></figure><p>参考</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">women</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.__age=<span class="number">18</span>  <span class="comment">#私有属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">script</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s是一个%d岁的people"</span>%(self.name,self.__age))  <span class="comment">#私有属性在方法内部可以调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__scrt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s是一个%d岁的people"</span>%(self.name,self.__age))</span><br><span class="line">xiaohua=women(<span class="string">"小花"</span>)</span><br><span class="line">xiaohua.script()</span><br><span class="line"><span class="comment">#print(xiaohua.__age)         #   将本行取消注释可以看到外部不能调用方法内部的私有属性</span></span><br><span class="line"><span class="comment">#xiaohua.__scrt()     #     将本行取消注释可以看到外部不能调用内部私有方法</span></span><br><span class="line">print(xiaohua._women__age)    <span class="comment">#  本行可以看出可以强制调用私有属性</span></span><br><span class="line">xiaohua._women__scrt()        <span class="comment">#   本行可以看出可以强制调用内部的私有方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#      所以说  以上私有属性和私有方法全是伪的   可以强制调用，不过不建议使用</span></span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">子类会继承父类所有的属性和方法</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span>:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">dog</span><span class="params">(animal)</span>:</span>   <span class="comment">#dog可以继承animal的属性和方法</span></span><br><span class="line">继承是有传递性的</span><br><span class="line">子类重写父类继承过来的方法，会调用重写的方法，而不会调用原来的方法</span><br><span class="line">子类可以扩展父类中的方法，super()函数可以调用父类中的方法</span><br><span class="line">super().继承的父类的方法，课可以在原父类的方法进行扩展</span><br></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>子类可以继承多个父类，并且具有所有父类的<strong>属性</strong>和<strong>方法</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类名<span class="params">(父类名<span class="number">1</span>,父类名<span class="number">2</span>,,,)</span></span></span><br><span class="line"><span class="class"><span class="title">pass</span></span></span><br></pre></td></tr></table></figure><h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tool</span><span class="params">(object)</span>:</span></span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        tool.count +=<span class="number">1</span>      <span class="comment">#调用类属性</span></span><br><span class="line">lei=tool(<span class="string">"小明"</span>)</span><br><span class="line">lei=tool(<span class="string">"小明"</span>)</span><br><span class="line">print(tool.count)<span class="comment">#输出类属性</span></span><br></pre></td></tr></table></figure><p>输出   2</p><h2 id="类属性、类方法、实例属性、实例方法、静态方法"><a href="#类属性、类方法、实例属性、实例方法、静态方法" class="headerlink" title="类属性、类方法、实例属性、实例方法、静态方法"></a>类属性、类方法、实例属性、实例方法、静态方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span><span class="params">()</span>:</span></span><br><span class="line">    Top_grade =<span class="number">0</span>                        <span class="comment">#定义类属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span>            <span class="comment">#定义实例属性</span></span><br><span class="line">        self.name=name</span><br><span class="line"><span class="meta">    @staticmethod                       #定义静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">help</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"打开大门，让僵尸进入脑子"</span>)</span><br><span class="line"><span class="meta">    @classmethod                        #定义类方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Top</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">"历史最高分是：%d"</span> %Game.Top_grade)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Start</span><span class="params">(self)</span>:</span>                    <span class="comment">#定义实例方法</span></span><br><span class="line">        print(<span class="string">"%s 开搞"</span> %self.name)</span><br><span class="line"></span><br><span class="line">Game.help()                 <span class="comment"># 调用静态方法，直接用类名调用</span></span><br><span class="line">Game.Top()                  <span class="comment">#调用类方法，类方法调用类属性</span></span><br><span class="line">game=Game(<span class="string">"小花"</span>)             <span class="comment">#创建对象</span></span><br><span class="line">game.Start()                <span class="comment">#调用实例方法</span></span><br></pre></td></tr></table></figure><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><h3 id="单例是什么"><a href="#单例是什么" class="headerlink" title="单例是什么"></a>单例是什么</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">            <span class="comment">#   单例模式创建的对象，多次调用其实是一个对象，只有一个空间内的地址</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">music</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span>    <span class="comment">#初始化对象空间</span></span><br><span class="line">        print(<span class="string">"单例"</span>)</span><br><span class="line">        cls.instense=super().__new__(cls)       <span class="comment">#为初始化方法设置一个变量接受其地址</span></span><br><span class="line">        <span class="keyword">return</span> cls.instense             <span class="comment">#返回该变量的地址</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"这是首歌"</span>)</span><br><span class="line">ge=music()</span><br><span class="line">print(ge)</span><br></pre></td></tr></table></figure><h3 id="单例模式设计代码"><a href="#单例模式设计代码" class="headerlink" title="单例模式设计代码"></a>单例模式设计代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">music</span><span class="params">()</span>:</span></span><br><span class="line">    instense = <span class="literal">None</span>                     <span class="comment">#设置一个类属性</span></span><br><span class="line">    flag=<span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span>    <span class="comment">#初始化对象空间</span></span><br><span class="line">        print(<span class="string">"单例"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cls.instense <span class="keyword">is</span> <span class="literal">None</span>:                <span class="comment">#检查类属性是否为空</span></span><br><span class="line">            cls.instense=super().__new__(cls)           <span class="comment">#调用父类方法为方法分配一个空间，并赋给类属性</span></span><br><span class="line">            <span class="keyword">return</span> cls.instense</span><br><span class="line">        <span class="keyword">return</span> cls.instense             <span class="comment">#返回类属性保存的对象引用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> music.flag:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(<span class="string">"这是首歌"</span>)</span><br><span class="line">        music.flag=<span class="literal">True</span></span><br><span class="line">ge=music()</span><br><span class="line">print(ge)</span><br><span class="line">ge2=music()</span><br><span class="line">print(ge2)</span><br></pre></td></tr></table></figure><h3 id="在单例中，实现初始化方法只执行一次"><a href="#在单例中，实现初始化方法只执行一次" class="headerlink" title="在单例中，实现初始化方法只执行一次"></a>在单例中，实现初始化方法只执行一次</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">music</span><span class="params">()</span>:</span></span><br><span class="line">    instense = <span class="literal">None</span>                     <span class="comment">#设置一个类属性</span></span><br><span class="line">    flag=<span class="literal">False</span><span class="comment">#设置一个类属性作为标记值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span>    <span class="comment">#初始化对象空间</span></span><br><span class="line">        print(<span class="string">"单例"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cls.instense <span class="keyword">is</span> <span class="literal">None</span>:                <span class="comment">#检查类属性是否为空</span></span><br><span class="line">            cls.instense=super().__new__(cls)           <span class="comment">#调用父类方法为方法分配一个空间，并赋给类属性</span></span><br><span class="line">            <span class="keyword">return</span> cls.instense</span><br><span class="line">        <span class="keyword">return</span> cls.instense             <span class="comment">#返回类属性保存的对象引用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> music.flag:<span class="comment">#判断类属性是否为真</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(<span class="string">"这是首歌"</span>)</span><br><span class="line">        music.flag=<span class="literal">True</span><span class="comment">#不为真则执行初始化方法，并改变标记值</span></span><br><span class="line">ge=music()</span><br><span class="line">print(ge)</span><br><span class="line">ge2=music()</span><br><span class="line">print(ge2)</span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>python程序在运行中遇到错误会停止执行，并且提示一些错误信息，这个就很叫做异常</p><p>程序停止执行并提示错误这个动作，称为  “抛出异常”</p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num=int(input(<span class="string">"输入一个整数："</span>))</span><br></pre></td></tr></table></figure><p>输入a会抛出异常</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个整数：a</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:/学习/python文件/异常.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    num=int(input(&quot;输入一个整数：&quot;))</span><br><span class="line">ValueError: invalid literal for int() with base 10: &apos;a&apos;</span><br></pre></td></tr></table></figure><p>捕获异常进行处理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num=int(input(<span class="string">"输入一个整数："</span>))</span><br><span class="line"><span class="keyword">except</span> ValueError:          <span class="comment">#捕获异常</span></span><br><span class="line">    print(<span class="string">"输整数啊"</span>)</span><br></pre></td></tr></table></figure><p>输入a出现以下结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个整数：a</span><br><span class="line">输整数啊</span><br></pre></td></tr></table></figure><h3 id="捕获未知异常"><a href="#捕获未知异常" class="headerlink" title="捕获未知异常"></a>捕获未知异常</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num=int(input(<span class="string">"输入一个整数："</span>))</span><br><span class="line">    print(<span class="number">8</span>/num)</span><br><span class="line"><span class="keyword">except</span> ValueError:          <span class="comment">#捕获异常</span></span><br><span class="line">    print(<span class="string">"输整数啊"</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> res:            <span class="comment">#  捕获未知异常</span></span><br><span class="line">    print(<span class="string">"未知错误  %s"</span>% res)</span><br></pre></td></tr></table></figure><p>效果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个整数：0</span><br><span class="line">未知错误  division by zero</span><br></pre></td></tr></table></figure><h3 id="主动抛出异常"><a href="#主动抛出异常" class="headerlink" title="主动抛出异常"></a>主动抛出异常</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">password</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"输入8位密码"</span>)</span><br><span class="line">    passwd=input()</span><br><span class="line">    <span class="keyword">if</span> len(passwd)&gt;=<span class="number">8</span>:               <span class="comment">#判断</span></span><br><span class="line">        <span class="keyword">return</span> passwd</span><br><span class="line">    print(<span class="string">"主动抛出异常"</span>)</span><br><span class="line">    ex=Exception(<span class="string">"密码长度不够"</span>)          <span class="comment">#  设定异常</span></span><br><span class="line">    <span class="keyword">raise</span> ex               <span class="comment">#  返回</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(password())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> res:</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用路由器做DHCP</title>
      <link href="/2019/08/08/%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E5%81%9ADHCP/"/>
      <url>/2019/08/08/%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E5%81%9ADHCP/</url>
      
        <content type="html"><![CDATA[<h1 id="用路由器做DHCP"><a href="#用路由器做DHCP" class="headerlink" title="用路由器做DHCP"></a>用路由器做DHCP</h1><p>R1(config)# ip dhcp pool vlan100   配置地址池名称</p><p>R1(dhcp-config)#network  192.168.100.0 255.255.255.0   分配地址范围</p><p>R1(dhcp-config)#default-router  192.168.100.254   分配的网关地址</p><p>R1(dhcp-config)#dns-server 61.139.2.69</p><p>R1(config)#ip dhcp excluded-address 192.168.1 192.168.1.10  排除地址</p><h1 id="DHCP中继"><a href="#DHCP中继" class="headerlink" title="DHCP中继"></a>DHCP中继</h1><h2 id="1-配置dhcp服务器"><a href="#1-配置dhcp服务器" class="headerlink" title="1.配置dhcp服务器"></a>1.配置dhcp服务器</h2><h2 id="2-在网关接口上配置转发"><a href="#2-在网关接口上配置转发" class="headerlink" title="2.在网关接口上配置转发"></a>2.在网关接口上配置转发</h2><p>switch(config)#int  vlan 10</p><p>ip(config-if)#helper-address 192.168.30.1</p><h2 id="3-pc端"><a href="#3-pc端" class="headerlink" title="3.pc端"></a>3.pc端</h2><p>pc&gt;ipconfig /release</p><p>pc&gt;ipconfig /renew</p><p>pc&gt;ipconfig /all</p>]]></content>
      
      
      
        <tags>
            
            <tag> 路由交换技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STP算法、pvst生成树</title>
      <link href="/2019/08/08/stp%E7%AE%97%E6%B3%95%E3%80%81pvst%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2019/08/08/stp%E7%AE%97%E6%B3%95%E3%80%81pvst%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="STP算法"><a href="#STP算法" class="headerlink" title="STP算法"></a>STP算法</h1><p>STP将一个环形网络生成无环拓扑的步骤</p><p>第一步：选择根网桥</p><p>第二部；选择根端口</p><p>第三步：选择指端口</p><h2 id="1-如何选择根网桥"><a href="#1-如何选择根网桥" class="headerlink" title="1.如何选择根网桥"></a>1.如何选择根网桥</h2><p>根据网桥ID(BID)选择根网桥，谁的优先级小，谁就是网桥。如果优先级相同，谁的MAC地址小谁就是网桥。</p><p>BID：优先级+MAC地址</p><p>​    默认情况下交换机的优先级是：37768</p><p>​    查看交换机的MAC地址：switch#show version</p><p>​    base ethernetMAC Address：0001，967e，9162</p><h2 id="2-选择根端口"><a href="#2-选择根端口" class="headerlink" title="2.选择根端口"></a>2.选择根端口</h2><h4 id="1-如何选择根端口"><a href="#1-如何选择根端口" class="headerlink" title="(1) 如何选择根端口"></a>(1) 如何选择根端口</h4><p>在非根网桥上选择一个到根网桥最近的端口作为根端口，选择端口的依据是：</p><p>​    根路径的成本（cost值）从端口出发到根桥最低</p><p>​    直连网桥的网桥ID最小</p><p>​    直连网桥的端口ID最小</p><h3 id="2-什么是cost值"><a href="#2-什么是cost值" class="headerlink" title="(2)什么是cost值"></a>(2)什么是cost值</h3><p>根路径成本是网桥到根网桥的路径上所有链路的成本之和。</p><h3 id="3-什么是端口ID"><a href="#3-什么是端口ID" class="headerlink" title="(3)什么是端口ID"></a>(3)什么是端口ID</h3><p>端口优先级(默认是128)+端口编号</p><h2 id="3-选择指定端口"><a href="#3-选择指定端口" class="headerlink" title="3.选择指定端口"></a>3.选择指定端口</h2><p>依据是</p><p>​    在每根网桥上选择一个指定端口，根桥上的端口全是指定端口。</p><p>非根桥上的指定端口：</p><p>​    根路径成本最低【从非根桥到根桥】</p><p>​    端口所在的网桥ID值较小</p><h1 id="pvst：按vlan生成树"><a href="#pvst：按vlan生成树" class="headerlink" title="pvst：按vlan生成树"></a>pvst：按vlan生成树</h1><h2 id="1-划分vlan"><a href="#1-划分vlan" class="headerlink" title="1.划分vlan"></a>1.划分vlan</h2><h2 id="2-设置sw1作为vlan10的根桥，sw2作为vlan10的备份根桥"><a href="#2-设置sw1作为vlan10的根桥，sw2作为vlan10的备份根桥" class="headerlink" title="2.设置sw1作为vlan10的根桥，sw2作为vlan10的备份根桥"></a>2.设置sw1作为vlan10的根桥，sw2作为vlan10的备份根桥</h2><p>sw1(config)#spanning-tree vlan 10 root primary</p><p>sw2(config)#spanning-tree vlan 10 root secondary</p><h2 id="3-设置sw2作为vlan20的根桥，sw1作为vlan20的备份根桥"><a href="#3-设置sw2作为vlan20的根桥，sw1作为vlan20的备份根桥" class="headerlink" title="3.设置sw2作为vlan20的根桥，sw1作为vlan20的备份根桥"></a>3.设置sw2作为vlan20的根桥，sw1作为vlan20的备份根桥</h2><p>sw2(config)#spanning-tree vlan 20 root primary</p><p>sw1(config)#spanning-tree vlan 20 root secondary</p><h1 id="配置端口聚合"><a href="#配置端口聚合" class="headerlink" title="配置端口聚合"></a>配置端口聚合</h1><p>sw1(config)#int port-channel 1  开启一个逻辑端口</p><p>sw1(config)#sw mo trunk</p><p>sw2(config)#int port-channel 1</p><p>sw2(config)#mo trunk</p><p>sw1(config)#int f0/4</p><p>sw1(config)#sw mo trunk</p><p>sw2(config)#int f0/4</p><p>sw2(config)#sw mo trunk</p><p>sw1(config)#int range f0/1,f0/4</p><p>sw1(config)#channel-group 1 mode on</p><p>sw2(config)#int range f0/1,f0/4</p><p>sw2(config)#channel-group 1 mode on</p><h1 id="配置流量均衡"><a href="#配置流量均衡" class="headerlink" title="配置流量均衡"></a>配置流量均衡</h1><p>switch(config)#int f0/1</p><p>switch(config)#spanning-tree vlan 10 port-priority 16</p><p>switch(config)#spanning-tree vlan 20 port-priority 32</p><p>switch(config)#int f0/2</p><p>switch(config)#spanning-tree vlan 10 port-priority 32</p><p>switch(config)#spanning-tree vlan 20 port-priority 16</p><h1 id="本征vlan"><a href="#本征vlan" class="headerlink" title="本征vlan"></a>本征vlan</h1><p>Switch(config-if)#switchport native vlan 99</p>]]></content>
      
      
      
        <tags>
            
            <tag> 路由交换技术 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
