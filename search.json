[{"url":"/2019/08/09/nmap/","content":"# nmap\n\n<!--more-->\n\n## nmap的功能\n\n·扫描主机端口\n\n·探测主机是否在线\n\n·推断主机操作系统类型\n\n### -sT  tcp扫描\n\n全连接扫描 ：  发送一个tcp的连接，不需要root用户即可，容易被探测到\n\n### -sS    SYN扫描\n\n半连接扫描：不是一个完整的tcp连接，只发送一个SYN包，返回\t\tSYN|ACK包说明端口正在监听，如果返回RST包说明端口没有监听程序，痕迹少，不易被发现，不过要root权限\n\n### -sF     FIN扫描\n\n​    秘密扫描   除SYN、ACK其他位置\n\n### \t-sX    Xmas扫描\n\n   秘密扫描    FIN、URG、PUSH位置\n\n### \t-sN   -null扫描\n\n   密码扫描   标志位全为0，发送TCP分组\n\n### \t-sP   ping扫描\n\n​    同时使用ICMP  TCP  ACK 80返回RST说明主机运行\n\n### \t-sU  UDP扫描\n\n   发送0字节UDP包，快速扫描windows的UDP端口\n\n### \t-sA  ACK扫描\n\n  TCP ACK扫描\n\n，防火墙开启时，查看防火墙未过滤端口\n\n### \t-P0\n\n  NMAP扫描前不ping主机\n\n### \t-PT\n\n  扫描前使用TCP  ACK包确定主机是否在运行  默认80端口\n\t-PS  TCP  SYN扫描\n\n### \t-PI\n\n  ping扫描\n\n### \t-O \n\n 扫描TCP/IP指纹特征，确定目标主机类型\n\n### \t-v \n\n 冗余模式扫描，可以得到扫描时的详细信息\n\n### \t-S\n\n   欺骗扫描时，用来指定主机IP\n\t"},{"url":"/2019/08/09/文件上传/","content":"# 文件上传\n\n<!--more-->\n\n## 本地验证绕过  js验证绕过\n\n​\t文件上传时在本地服务器进行验证，此时可以将php文件的后缀改为符合要求的，然后用burp suite抓包，再将后缀改为php即可\n\n## 文件后缀绕过\n\n​\t建立一个a.php.xxx的文件，xxx为读不出来的文件后缀即可\n​\t原理是文件读取时是从右往左读取，当后缀读不出来时，到.php时会执行php文件\n\n## 文件类型绕过\n\n​\t验证文件类型的mime值，当mime值符合要求时才能上传，此时只需要burp suite抓包，将mime值改为符合要求的即可\n\n## 文件截断绕过\n\n源码对上传文件进行php限制\n截断字符:0x00    %00    /00   char()为null，后面内容会被截断\n利用条件：php版本小于5.3.4    php参数magic_quotes_gpc设置为关off\n\n## 竞争上传（多线程，并发）：\n\n源码对上传的文件类型为php的存储后删除。\n通过上传php生成一句话，在路径下生成反弹木马\n自动生成一句话木马的脚本。\n\n## 图片马\n\ncat 1.jpg/a  2.php/b  3.jpg\ncopy  1.jpg/a  2.php/b  3.jpg   将图片和php制作成一个图片马\n此上传只有对方有文件包含漏洞时才能使用\n\n## 二次渲染\n\n待定······"},{"url":"/2019/08/09/热备份路由协议/","content":"# 热备份路由协议\n\n<!--more-->\n\n## HSRP配置\n\nsw(config)#int vlan 10 \n\nsw(config-if)#standby 10 ip 192.168.10.250          将vlan10这个端口设置到10并配置一个地址\n\nsw(config-if)#standby 10 priority 120   设置优先级\n\nsw(config)#standby  10  times 3  10  设置每隔3s发一次，10s保持\n\nsw(config)#standby 10 preempt  设置抢占模式\n\nsw(config)#standby 10 track f0/22   设置跟踪端口\n\n两边路由器都要设置"},{"url":"/2019/08/09/配置静态路由/","content":"# 静态路由\n\n<!--more-->\n\nIP route +目标地址  +转发接口地址\n\n在不知道外部网络的情况下\n\nIP route 0.0.0.0 0.0.0.0 f0/0\n\n## 使用静态路由实现负载均衡\n\nR1(config)#ip route 23.1.1.0 255.255.255.0 172.16.1.2\n\nR1(config)#ip route 23.1.1.0 255.255.255.0 12.1.1.2\n\nR2(config)#ip route 12.1.1.0 255.255.255.0 172.16.1.1\n\nR2(config)#ip route 12.1.1.0 255.255.255.0 23.1.1.1\n\nR3(config)#ip route 172.16.1.0 255.255.255.0 12.1.1.1\n\nR3(config)#ip route 172.16.1.0 255.255.255.0 23.1.1.2\n\n## 选择静态路由\n\n静态路由会根据子网掩码大的优先选择，即静态路由的最长匹配原则\n\n## 浮动静态路由\n\nR3(config)#ip route 172.16.1.0 255.255.255.0 23.1.1.2 10(浮动，值越小优先)\n\n"},{"url":"/2019/08/09/ssh远程管理网路设备：/","content":"# ssh远程管理网路设备：\n\n<!--more-->\n\ntelnet  也可以管理，不过telnet使明文传输  telnet使用23端口\n\n为了提高安全，使用ssh，密码进行了加密  使用22端口\n\n配置ssh：\n\n配置交换机名字\n\nswitch(config)#hostname  sw1\n\n配置域名\n\nsw1(config)#ip domain-name ccie.com\n\n配置加密方式\n\nsw1(config)#crypto key generate rsa\n\n配置密码加密长度\n\n512的倍数\n\n设置用户名和密码\n\nsw1(config)#username admin password ccie\n\n或者sw1(config)#username admin  privilege（权限级别）  0  secret ccie\n\nserver(config)#line vty 0 4\n\nserver(config-line)#exec-timeout 10 0（10分钟没有进行操作，断开连接）\n\nserver(config-line)#logging synchronous\n\nserver(config-line)#login local\n\nserver(config-line)#transport input ssh（选择登陆方式）\n\nssh -l +用户名 +ip"},{"url":"/2019/08/09/SQL注入绕过/","content":"# SQL注入绕过\n\n<!--more-->\n\n## 1.空格绕过：\n\n​\t/**/    %a0   括号也可以绕过空格 括号两边可以不用加空格如：where（1=1）\n\n## 2.引号绕过：\n\n​\t十六进制绕过：将引号括起来的语句用十六进制表示\n\n## 3.逗号绕过：\n\n​\tfrom  for绕过，如select substr(database() from 1 for 1)\n​\tjoin绕过union select 1,2   #等价于\n​\t\tunion select * from (select 1)a join (select 2)b\n​\tlike绕过    limit可以使用offset绕过\n​\t\t如select *from news limit 0,1   #等价于\n​\t\t\tselect * from news limit 1 offset 0\n\n## 4.大于号>小于号<绕过    \n\n​\tgreatest()、least()前者返回最大值，后者返回最小值\n​\tgreatest(1,5,6,2,3,1)  返回6\n​\tbetween and  #between a and b  返回a和b之间的数据  不包含b\n\n## 5.or   and   xor  not  绕过\n\n​\tand 用&&   or用||   xor用|  not用!\n\n## 6.绕过注释符号   过滤注释符号\n\n​\t使语句闭合\n\n## 7.=绕过\n\n​\tlike    rlike  regexp  或者用“或者”\n\n## 8.绕过union  select  where等sql常用语句\n\n​\t注释符绕过。。暂定 看不懂\n​\t大小写绕过  #语句大小写混合输入  id=-1' UnIoN SeLecT\n​\t内联注释绕过/*！  */\n​\t双关键字绕过  适用于只过滤一次关键字的注入\n\n## 9.通用绕过\n\n​\t编码绕过   urlencode   ascii  hex  unicode\n\n## 10.宽字节注入\n\n​\t%df和转义符形成一个特殊字符从而吃掉‘转义符’ 让%df后面的字符逃过转义\n\n## 11.等价函数\n\n​\tdatadir()=@@datadir等"},{"url":"/2019/08/08/SQL注入/","content":"# SQL注入\n\n<!--more-->\n\nsql注入是web应用程序对用户的输入数据的合法性没有判断，前端传入的数据是攻击者可控的，并且可以带入数据库查询，攻击者可以构造不同的sql语句来实现自己的目的\n\n## 注入之前的尝试\n\n我们可以通过输入带有特殊符号的不同的参数来对输入点进行测试，该位置是否存在注入点。\n\n1\n\n1 and 1=1\n\n1 and 1=2\n\n1 or 1=2\n\n1'\n\n1' and 1=1\n\n1' and 1=2\n\n1' or 1=1\n\n如果出现错误页面就说明存在注入点，特殊符号不仅仅是指\"  '  \"  也包括()\"\"甚至也可能不止一层\n\n## MySQL与sql注入的一些知识点\n\n在MySQL5.0以上的版本，数据库中存在一个“information_schema”的数据库，我们需要记住该数据库中的三个表，schemamata,tables,columns\n\n·schemamata这个表存放所有数据库的名字，表中数据库的名字字段是schema_name \n\n·tables表存放所有数据库的库名以及表名，字段分别为table_schema和table_name\n\n·columns表中存放用户创建的所有数据库的库名、表名、字段名，他们的字段名分别是，table_schema,  table_name,  column_name \n\n\n\n## 一些常用的函数\n\nselect   查询的字段名  from 库名.表名\n\nlimit的用法\n\nlimit的格式是limit(n,m)，其中n是开始的位置，m为取几条记录\n\n如select * from test.user limit 1,2\n\n查询所有列从test库中的user表，从第二行开始一共取2行\n\nversion()   当前数据库的版本\n\ndatabase()当前网站使用的数据库\n\nuser()当前MySQL的用户\n\n三种常用的注释符\n\n1.#\n\n2.--+或者--空格\n\n3./**/    *中的内容会被注释\n\n## union注入\n\n联合注入是在参数输入的地方拼接另一个查询语句，使数据库执行此语句，从而达到目的\n\nunion select database() --+\n\nunion select table_name from intormation_schema.tables where table_schema=database() --+\n\n"},{"url":"/2019/08/08/python/","content":"# python学习笔记\n\n<!--more-->\n\n## 输入输出\n\n```             python\nprint(' '，“ ”)  #输出单双引号皆可  引号括起来就是字符，不括就是整型\nprint （'''test\n\ttest\n\ttest'''）#换行输出单双引号皆可\n\ta=input（'  '） #键盘输入a只能是str\n\t#可以用a=int(a) 将a转化为整型\n\t #字符串中\\可以标识' 和\" ,比如\n'i\\'m\\''ok\\''!' 表示 i'm ''ok''!\ns=input('as',end='')#如果显示不换行在后面加end=''，默认换行\n\t#%是取余除法，是永远取整数的除法\n```\n\n### 编码\n\n``` python\n'ABC'.encode('ascii')\nb'ABC'   #将ABC从str转化成bytes\nb'ABC'.decode('ascii')\n'ABC'  #将bytes转化为str\nlen()#可以计算字符长度\n```\n\n### 参数\n\n``` \n#前面传入参数'{0}，{1}，{2}'.format('a','b','c')\n\t#%d  double整数型  %.2f  浮点型两位小数\n\t#%s  str字符串    %\n```\n\n### list\n\n``` python\nclass=['a','b','c']   #class是一个集合，可以增删改的list\nlen(class)\n\t3   #list的元素个数\nclass[0]\t\t\t\t#读取第一个元素class[-1]读取倒数第一个元素\nclass.append('d')  \t\t#添加一个元素在末尾\nclass.insert(1,'1') \t#添加到索引号为1的位置\nclass.pop(i)\t\t\t#删除指定位置元素\nclass(1)='2'  \t\t\t#直接赋值给索引号为1的元素，从而替换该元素的值\n#list中的元素可以不同，整型、字符串、等等\nclass1=['l'.'m']      \nclass2=['n',class1] \t #list中可以存放class2可以看为二维数组\n```\n\n### tuple\n\n``` python\nt=（1，2）  \t\t#tuple一经确定不能修改\nt=(1,)  \t\t\t#tuple在定义只有一个元素的时候用逗号消除歧义\nt=('a','b',['x','y']) #在创建时可以在tuple中添加一个list从而改变tulp中的元素的目的\n```\n\n## 条件判断\n\n### if\n\n``` python\n#if语句后面要加:冒号  \n\t#可以执行多个elif语句\n\t#if语句执行从上往下，一但符合条件立即结束\nimport math\ndef qiujie(a,b,c):\n    if (b*b-4*a*c)<0:\n        print('无实根')\n    else:\n        x1=(-b+math.sqrt(b*b-4*a*c))/(2*a)\n        x2=(-b-math.sqrt(b*b-4*a*c))/(2*a)\n        x=move(x1,x2)\n        print(x)\n```\n\n## 循环\n\n### while\n\n``` \n\t#while语句当条件满足时会一直循环，不满足时退出\n\t#break可以退出循环，一般与if判断语句一起用\n\t#continue语句会跳过当前循环，符合本语句的循环会直接跳过\n```\n\n## 字典\n\n### dict--dictionary\n\n```  python\nd={'a':1,'b':2,'c':3} #a相当于key、页码之类的  可以快速翻页查找目标\n\td['a']=4  #可以直接用key来将元素放入，后放入的元素会把前面的冲掉\n\td.get('kkk')  #判断key是否在字典中也可以设定\n    d.get('kkk',-1)   #返回-1 即当kkk不存在时返回-1\n\td.pop('kkk') #删除key之后对应的元素也会被删掉\n```\n\n### set\n\n``` python\ns=set([1,2,3,])  #set也是一组key值 但是不能存储value，没有重复的key\ns=set([1,2,2,3,3,])  #重复元素会被过滤掉\ns.add(2)  #add可以添加元素可以重复添加，但会被过滤\n```\n\n## 函数\n\n### def\n\n``` python\ndef a():在随意文件里xx.py中创建一个函数为a\n·import xx from a  #将xx中的a函数调用函数可以返回多个值，其实就是一个tuple\n```\n\n### 参数\n\n``` python\n*num表示把num这个list或者tuple的所有元素变成可变的参数传进去\n关键字参数def person(name,age,**k)  #k就是关键字参数 //调用该参数时可以只传入一\t个关键字参数\n```\n\n### 递归函数\n\n``` python\ndef digui(n):\n    \t\tif n==1:\n        \t\t\treturn 1\n    \t\treturn n * digui(n-1)   # 函数调用自身的一种函数，不过会出现栈溢出的问题\n\n\tdef digui(n):\n    \t\treturn digui2(n,1)\n\tdef digui2(n,s):\n    \t\tif n==1:\n        \t\t\treturn s\n    \t\treturn digui2(n-1,n*s)   #尾递归可以解决栈溢出问题，但是大多数解释器没优化，故还是会造成栈溢出\n\n```\n\n### 切片操作\n\n``` python\n\t[0:3]  #切取前3个元素，--不是从1开始，是从第一个元素开始\n\t[0:5:2] #在前5个元素中，每隔两个取一次\n\t[:5] #当第一个索引是从0开始时，0可以省略\n\t[:]  #原样复制一个list\n\t'asdasdada'  [0:3] #字符串也可以切取，结果也是字符串\n\t(1,2,3,4,5) [0:2]  #tuple也可以切取，结果为tuple\n```\n\n### 迭代\n\n``` python\n\tfor xx in l  #for可以迭代各种对象\n\tfrom colletions import Iterable  #collections中的iterable模块可以判断是否可以迭代\n\tisinstance([1,2,3,4])\n```\n\n### 列表生成式\n\n``` python\n\tlist(range(1,10))  #生成1到9的列表\n\t[x*x for x in range(1,10)]  #生成1*1到9*9的一个列表\n\t[m+n for m in 'abc' for n in 'xyz']  #双层循环\n```\n\n### 生成器\n\n生成器输出用yield ()  yield输出后停止，下次开始时从停止的地方继续\n\n参照杨辉三角\n\n``` python\ndef yang():\n    b=[1]\n    while True:    #永真\n        yield b     #执行时停止循环，下次执行从下一行开始\n        b=[1]+[b[i]+b[i+1]for i in range(len(b)-1)]+[1] #三个列表拼起来\nn=0\nfor t in yang():\n    print (t)\n    n=n+1\n    if n ==10:\n        break\n```\n\n\n\n### 高阶函数\n\n函数值可以赋给变量，函数本身也可以--变量可以指向函数\n\t**函数可以作为一个参数使用**\n\n``` python\ndef fun()\n\t\tprint('a')\n\t      def gg(x,y)\n\t\tprint(x,y)\n\t可以使用gg(x,fun())来调用  不过先返回的函数？\n```\n\n### map()/reduce()\n\n``` python\nmap(fun,3,2,5,6,5,4,2,1)    # map会将后面参数全部带入函数fun中\n\treduce(gg,3,2,5,4,5,6,7,)   #函数gg必须为输入两个参数的，map会将3和2参数放\t\t入，并将结果和5一起传入参数，以此类推\n```\n\n## 全局变量global\n\nglobal  告诉解释器定义的为全局变量，声明一个变量变为全局变量\n\n``` python\na=4\ndef hanshu():\n    global a   #定义全局变量\n    a=2\n    print(a)\n\ndef hanshu2():\n    a=8\n    print(a)\n\ndef hanshu3():\n    print(a)\nhanshu2()\nhanshu3()\nhanshu()\n```\n\n\n\n## 转义符\n\n\\t可以让输出垂直对齐，\\n换行\n\n## 常用函数(·补充)\n\ndir()可以查看对象的使用方法\n\n## 类和对象\n\n``` \n先有类，后有对象\n对象调用类中的方法\n可以利用   .属性名=\"属性\"   给对象增加属性\n初始化方法  __init__\n\t在初始化方法中设定属性用  self.属性名=\"属性\"\n\t在对象调用类的时候会自动使用设定的初始化方法\n对__init__设置形参可以使初始化方法更加灵活\n\tclass cat():\n\tdef __init__(self,new_name)\n\t\tself.name=new_name\n\t等调用时直接传入形参\n\ttom=cat(\"tom\")即可将tom赋值给self.name进而传给tom这个对象\n\n__del__会在对象销毁之前调用\n__str__能够让print输出对象的时候返回一个字符串而不是地址\n\n同一个类创造出来的对象互不干扰\n```\n\n参照\n\n``` python\nclass stu():        #  创建类\n    def stu1(self):     #创建类的方法\n        print(\"%s\" %self.name,end=\"\")\n    def syu2(self):\n        print(\"%d\" %self.id)\ndt=stu()\n\ndt.name=\"dt\"\ndt.stu1()   #调用类\ndt.id=1\ndt.syu2()    #调用类\nzw=stu()\nzw.name=\"zw\"\nzw.id=2\nzw.stu1()\nzw.syu2()\n```\n\n### 伪私有属性和方法\n\n```python\n定义一个类  class women:\n在设定一个属性时在属性名前加两个_可以将属性私有，私有属性只能在方法中调用\t\t，在类外不能调用\n\tself.__age\n同样私有方法也不能在外界访问\n\tdef __sy(self):\n     私有属性和私有方法同样可以调用\n\txiaofang=women(\"小芳\")\n\tprint(xiaofang._women__age)调用属性\n\txiaofang._women__sy()调用方法\n```\n参考\n\n``` python\nclass women:\n    def __init__(self,name):\n        self.name=name\n        self.__age=18  #私有属性\n    def script(self):\n        print(\"%s是一个%d岁的people\"%(self.name,self.__age))  #私有属性在方法内部可以调用\n    def __scrt(self):\n        print(\"%s是一个%d岁的people\"%(self.name,self.__age))\nxiaohua=women(\"小花\")\nxiaohua.script()\n#print(xiaohua.__age)         #   将本行取消注释可以看到外部不能调用方法内部的私有属性\n#xiaohua.__scrt()     #     将本行取消注释可以看到外部不能调用内部私有方法\nprint(xiaohua._women__age)    #  本行可以看出可以强制调用私有属性\nxiaohua._women__scrt()        #   本行可以看出可以强制调用内部的私有方法\n\n\n\n\n\n#      所以说  以上私有属性和私有方法全是伪的   可以强制调用，不过不建议使用\n```\n\n### 继承\n\n``` python\n子类会继承父类所有的属性和方法\n\t\tclass animal:\n\t\tclass  dog(animal):   #dog可以继承animal的属性和方法\n\t继承是有传递性的\n\t子类重写父类继承过来的方法，会调用重写的方法，而不会调用原来的方法\n\t子类可以扩展父类中的方法，super()函数可以调用父类中的方法\n\tsuper().继承的父类的方法，课可以在原父类的方法进行扩展\n```\n\n### 多继承\n\n子类可以继承多个父类，并且具有所有父类的**属性**和**方法**\n\n``` python\nclass 子类名(父类名1,父类名2,,,)\n\tpass\n```\n\n"},{"url":"/2019/08/08/用路由器做DHCP/","content":"# 用路由器做DHCP\n\n<!--more-->\n\nR1(config)# ip dhcp pool vlan100   配置地址池名称\n\nR1(dhcp-config)#network  192.168.100.0 255.255.255.0   分配地址范围\n\nR1(dhcp-config)#default-router  192.168.100.254   分配的网关地址\n\nR1(dhcp-config)#dns-server 61.139.2.69\n\nR1(config)#ip dhcp excluded-address 192.168.1 192.168.1.10  排除地址\n\n# DHCP中继\n\n## 1.配置dhcp服务器\n\n## 2.在网关接口上配置转发\n\nswitch(config)#int  vlan 10\n\nip(config-if)#helper-address 192.168.30.1\n\n## 3.pc端\n\npc>ipconfig /release\n\npc>ipconfig /renew\n\npc>ipconfig /all\n\n"},{"url":"/2019/08/08/stp算法、pvst生成树/","content":"# STP算法\n\n<!--more-->\n\nSTP将一个环形网络生成无环拓扑的步骤\n\n第一步：选择根网桥\n\n第二部；选择根端口\n\n第三步：选择指端口\n\n## 1.如何选择根网桥\n\n根据网桥ID(BID)选择根网桥，谁的优先级小，谁就是网桥。如果优先级相同，谁的MAC地址小谁就是网桥。\n\nBID：优先级+MAC地址\n\n​\t默认情况下交换机的优先级是：37768\n\n​\t查看交换机的MAC地址：switch#show version\n\n​\tbase ethernetMAC Address：0001，967e，9162\n\n## 2.选择根端口\n\n#### (1) 如何选择根端口\n\n在非根网桥上选择一个到根网桥最近的端口作为根端口，选择端口的依据是：\n\n​\t根路径的成本（cost值）从端口出发到根桥最低\n\n​\t直连网桥的网桥ID最小\n\n​\t直连网桥的端口ID最小\n\n### (2)什么是cost值\n\n根路径成本是网桥到根网桥的路径上所有链路的成本之和。\n\n### (3)什么是端口ID\n\n端口优先级(默认是128)+端口编号\n\n## 3.选择指定端口\n\n依据是\n\n​\t在每根网桥上选择一个指定端口，根桥上的端口全是指定端口。\n\n非根桥上的指定端口：\n\n​\t根路径成本最低【从非根桥到根桥】\n\n​\t端口所在的网桥ID值较小\n\n# pvst：按vlan生成树\n\n## 1.划分vlan\n\n## 2.设置sw1作为vlan10的根桥，sw2作为vlan10的备份根桥\n\nsw1(config)#spanning-tree vlan 10 root primary\n\nsw2(config)#spanning-tree vlan 10 root secondary\n\n## 3.设置sw2作为vlan20的根桥，sw1作为vlan20的备份根桥\n\nsw2(config)#spanning-tree vlan 20 root primary\n\nsw1(config)#spanning-tree vlan 20 root secondary\n\n# 配置端口聚合\n\nsw1(config)#int port-channel 1  开启一个逻辑端口\n\nsw1(config)#sw mo trunk\n\nsw2(config)#int port-channel 1\n\nsw2(config)#mo trunk\n\nsw1(config)#int f0/4\n\nsw1(config)#sw mo trunk\n\nsw2(config)#int f0/4\n\nsw2(config)#sw mo trunk\n\nsw1(config)#int range f0/1,f0/4\n\nsw1(config)#channel-group 1 mode on\n\nsw2(config)#int range f0/1,f0/4\n\nsw2(config)#channel-group 1 mode on\n\n# 配置流量均衡\n\nswitch(config)#int f0/1\n\nswitch(config)#spanning-tree vlan 10 port-priority 16\n\nswitch(config)#spanning-tree vlan 20 port-priority 32\n\nswitch(config)#int f0/2\n\nswitch(config)#spanning-tree vlan 10 port-priority 32\n\nswitch(config)#spanning-tree vlan 20 port-priority 16\n\n"}]